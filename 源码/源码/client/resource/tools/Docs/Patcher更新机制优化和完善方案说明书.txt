
			patcher更新机制优化和完善方案说明书


方案目的：  

	自动包更新模式启用时设计和实现了一个断点续传下载方案，
	根据1.0.126版本通过后台更新1.0.127模式的监测效果，
	我们发现，当后台更新刚刚发布时，短时间内会有大量的连接请求尝试到服务器下载更新文件，
	这会导致，一些相对比较大的子包的清单文件(.files2.meta)，比如map,monster等，
	在下载这些子包清单文件时往往因为超时等原因导致下载中断。

	为了适应此种原因导致下载失败的情况，将断点续传下载机制也用在了子包清单文件的下载中。
	这样做的好处就是，即使下载中断，已经下载成功的清单文件和数据在重新尝试下载时不会重复下载，
	从而在几乎不增加网络流量的情况下，用户可以通过重试机制完成整个后台更新过程。

方案描述：

	子包文件(cfg,effect,pak,map,monster...)下载时，在缓存目录(一般为“XXXX.cache”)下会有对应的子目录生成，
	相应的子目录清单文件(.files2.meta)会下载到该子目录下。
	新方案的做法是，在下载.files2.meta时，会同时生成一个对应的断点续传配置文件.files2.meta.cfg文件。
	该文件需要记录如下信息：
		1.当前下载的进度(offset), 4字节。
		2.完整文件的长度(total)，8字节。高四位暂时保留，应该总是为0。
		3.完整文件的摘要(hash)，8字节。

	这3个信息按如下方式提供下载文件的进度和完整性描述：
		1. 当前进度值，0~total，一般不会是0。
		2. 完整文件长度，描述了整个.files2.meta文件当时下载时在服务器上的长度信息，即文件需要下载的数据量。
		3. 完整文件的摘要，描述了.files2.meta文件当时下载时在服务器上的摘要信息，注意不是下载的片段文件的摘要。

	当文件下载开始时，通过判断如下逻辑确定文件的下载状态和后续流程：
		a) 文件尚未开始下载
		b) 已经下载完毕、可接受
		c) 尚未下载完毕、可继续下载未完成的部分
		d) 无论下载完毕与否，都需要废弃，并重新开始下载

	为了方便说明问题，专门定义当前服务器端完整文件的摘要信息（以下称hash2)，以区别于配置文件中的hash值
	（因为二者可能不一样）:	hash2 - 断点续传模块开始之前，已经下载了服务器上的.setup.meta文件，从中取得此值。

	.files2.meta.cfg 不存在或.files2.meta.cfg文件无法正确读取数据，结论(a)
	.files2.meta.cfg 读取的3项数据满足 offset==total, hash = hash2，结论(b)
	.files2.meta.cfg 读取的3项数据满足 offset<total, hash = hash2，结论(c)
	.files2.meta.cfg 读取的数据满足 hash != hash2，结论(d)

	为了获取完整文件的摘要信息(hash2)，我们对打包工具和.setup.meta文件的格式做了如下补充性修改。
	原有方案的.setup.meta中，记录的子包文件的hash值仅仅是.files.meta的hash值，而我们从服务器上
	获得的却是子包清单却是.files2.meta，这2个文件的逻辑一致，但hash值不一样，因此，我们不能用
	此hash值校验文件的完整性。因此，我们在.setup.meta中的每一个子包项目中，增加一项属性h2，用
	此属性记录.files2.meta的hash值，打包工具(PackZip)在合并data.pfs时，也同时在.setup.meta中
	增加一份.files2.meta本身的hash值。为了做到跨版本更新时的向后兼容问题，.setup.meta中的h2属性
	是可选属性，读.setup.meta时，如果此属性不存在，视h2为0，写.setup.meta时，如果h2为0，不写入
	.setup.meta文件。基于此，上述过程中描述的完整文件的hash值，如果为0，仅仅通过offset==total决定
	文件是否下载完毕，而不进行hash校验。从服务器的.setup.meta中读取的h2值，就是前面定义的hash2。

	此方案是通过修改和完善断点续传模块实现的，因此，会同时影响原有的断点续传方案。
	不过，原有方案因为尚未启用，所以不会有历史遗留问题和负面影响。


测试流程：

	1. 准备XX客户端最新版本，已含有此方案的patcher的客户端。为了重复测试，备份此客户端。
	2. 发布更新的客户端版本，更新某些子包(cfg,map,monster等)
	3. 用步骤1中准备的客户端进行更新，更新检测到2中的新版本后，将会开始下载文件清单，此时手工断网或者中途退出更新程序。
	为了重复测试，本步骤中的结果状态(缓存目录)需要备份若干份，或重复生成有区别的中间未更新完毕状态。
	4. 到客户端缓存目录下(一般为隐藏的"XXXX.cache")中查找子包清单文件.files2.meta文件和.file2.meta.cfg文件
	验证前者的大小和后者的数据的对应关系。因为.files2.meta.cfg为二进制文件，应该使用UltraEdit等工具查看。
	.files2.meta.cfg文件中记录的hash值，可以通过梦诛log目录下的patcher.log文件记录的日志去对照。
	5.1 恢复网络通道，继续更新步骤3中的版本，测试能否更新成功。
	5.2 为了验证hash过期的逻辑，此时可以再发布一个新版本，比如又更新了cfg，用步骤3中的副本继续更新，
	此时应该是跨版本更新逻辑，保证过期的清单文件会重新下载。不过期的文件会继续保留。

